package {{ .ARPkg }}

import (
	"bytes"
	"context"
	"fmt"
	"log"
{{ if eq .Server.Conf "" -}}
	"time"
{{ end }}
	"strings"

	"github.com/mailru/activerecord/pkg/iproto/iproto"
	"github.com/mailru/activerecord/pkg/activerecord"
	"github.com/mailru/activerecord/pkg/octopus"
{{- range $ind, $imp := .Imports }}
	{{ if ne $imp.ImportName "" }}{{ $imp.ImportName }} {{ end }}"{{ $imp.Path }}"
{{- end }}
{{- range $i, $imp := addImport .FieldList }}
	"{{ $imp }}"
{{- end }}
)
{{ $pkgName := .ARPkg }}
{{ $serializers := .Serializers -}}
{{ $mutators := .Mutators -}}
{{ $PublicStructName := .ARPkgTitle -}}
{{ $LinkedObject := .LinkedObject }}
{{ $flags := .Flags }}
{{ $fields := .FieldList }}
{{ $procfields := .ProcOutFieldList }}
{{ $procInLen := len .ProcInFieldList }}
{{ $mutatorLen := len .Mutators }}

    {{ if ne $mutatorLen 0 -}}
    type Mutators struct {
    {{- range $i, $mut := $mutators }}
        {{$mut.Name}}    octopus.MutatorField
		field{{ $mut.Name }}Original {{$mut.Type}}
    {{- end }}
    }
    {{ end -}}

{{ if $fields }}
    type {{ $PublicStructName }} struct {
        octopus.BaseField
        {{- if ne $mutatorLen 0 }}
        Mutators
        {{- end -}}
    {{- range $ind, $fstruct := .FieldList -}}
        {{ $rtype := $fstruct.Format -}}
        {{ $serlen := len $fstruct.Serializer -}}
        {{ if ne $serlen 0 -}}
            {{ $sname := index $fstruct.Serializer 0 -}}
            {{ $serializer := index $serializers $sname -}}
            {{ $rtype = $serializer.Type -}}
        {{ end }}
        field{{ $fstruct.Name }} {{ $rtype -}}
    {{ end }}
    }

    type {{ $PublicStructName }}List []*{{ $PublicStructName }}

    const (
        namespace uint32 = {{ .Container.ObjectName }}
        cntFields uint32 = {{ len .FieldList }}
    {{- range $fieldname, $flag := .Flags -}}
        {{ range $i, $flagname := $flag.Flags }}
        {{ $fieldname }}{{ $flagname }}Flag = 1 << {{ $i -}}
        {{ end -}}
    {{ end }}
    )

    {{ if .Triggers.RepairTuple.Params.Defaults -}}
    var defaultValue = [][]byte{
    {{- $notfirst := false -}}
    {{ range $ind, $fstruct := .FieldList -}}
        {{ $packerparam := packerParam $fstruct.Format -}}
        {{ if $notfirst }},{{ end -}}
        {{ $notfirst = true }}
        {{ $packerparam.DefaultValue -}}
    {{ end -}}
    }
    {{- end }}
{{end}}

{{ if $procfields }}
// proc struct
type {{ $PublicStructName }} struct {
    params {{ $PublicStructName }}Params
{{- range $ind, $fstruct := .ProcOutFieldList }}
    {{ $rtype := $fstruct.Format -}}
    {{ $serlen := len $fstruct.Serializer -}}
    {{ if ne $serlen 0 -}}
        {{ $sname := index $fstruct.Serializer 0 -}}
        {{ $serializer := index $serializers $sname -}}
        {{ $rtype = $serializer.Type -}}
    {{ end -}}
    field{{- $fstruct.Name }} {{ $rtype -}}
{{ end }}
}

type {{ $PublicStructName }}List []*{{ $PublicStructName }}

const (
    procName string = "{{ .Container.ObjectName }}"
    cntOutFields uint32 = {{ len .ProcOutFieldList }}
    )

{{- range $ind, $fstruct := .ProcOutFieldList -}}
{{ $rtype := $fstruct.Format -}}
{{ $sname := $fstruct.Serializer.Name -}}
{{ if ne $sname "" -}}
    {{ $serializer := index $serializers $sname -}}
    {{ $rtype = $serializer.Type -}}
{{ end }}
    func (obj *{{ $PublicStructName }}) Get{{ $fstruct.Name }}() {{ $rtype }} {
        return obj.field{{ $fstruct.Name }}
    }
{{ end }}

type {{ $PublicStructName }}Params struct {
{{- range $ind, $fstruct := .ProcInFieldList -}}
    {{ $rtype := $fstruct.Format -}}
    {{ $serlen := len $fstruct.Serializer -}}
    {{ if ne $serlen 0 -}}
        {{ $sname := index $fstruct.Serializer 0 -}}
        {{ $serializer := index $serializers $sname -}}
        {{ $rtype = $serializer.Type -}}
    {{ end }}
    {{ $fstruct.Name }} {{ $rtype -}}
{{ end }}
}

func (obj *{{ $PublicStructName }}) GetParams() {{ $PublicStructName }}Params {
    return obj.params
}

func  (obj *{{ $PublicStructName }}) setParams(params {{ $PublicStructName }}Params) error {
	obj.params = params

	return nil
}

{{ if ne $procInLen 0 }}
func (obj *{{ $PublicStructName }}Params) arrayValues() ([]string, error)  {
ret := []string{}
{{ range $ind, $fstruct := .ProcInFieldList -}}
    {{ $sname := $fstruct.Serializer.Name -}}
	{{ $bvar :=  $fstruct.Name -}}
	{{ if ne $sname "" -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $serparams := $fstruct.Serializer.Params -}}
	pvar{{ $fstruct.Name }}, err := {{ $serializer.ImportName }}.{{ $serializer.Marshaler }}({{ $serparams }}obj.{{ $bvar }})
	if err != nil {
		return nil, fmt.Errorf("error marshal param field {{ $fstruct.Name }}: %w", err)
	}

        {{ if eq $fstruct.Format "[]string" }}
        ret = append(ret, pvar{{ $fstruct.Name }}...)
	    {{ else }}
	    ret = append(ret, string(pvar{{ $fstruct.Name }}))
	    {{- end }}
	{{- else -}}
	ret = append(ret, string(obj.{{ $fstruct.Name }}))
	{{- end }}
{{ end }}
	return ret, nil
}
{{ end }}

func (obj {{ $PublicStructName }}Params) PK() string {
    return fmt.Sprint({{ if ne $procInLen 0 }}obj.arrayValues(){{ end }})
}

func Call(ctx context.Context{{ if ne $procInLen 0 }}, params {{ $PublicStructName }}Params{{ end }}) (*{{ $PublicStructName }}, error) {
    return call(ctx{{ if ne $procInLen 0 }}, params{{ end }}, activerecord.ReplicaOrMasterInstanceType)
}

func CallOnMaster(ctx context.Context{{ if ne $procInLen 0 }}, params {{ $PublicStructName }}Params{{ end }}) (*{{ $PublicStructName }}, error) {
    return call(ctx{{ if ne $procInLen 0 }}, params{{ end }}, activerecord.MasterInstanceType)
}

func call(ctx context.Context{{ if ne $procInLen 0 }}, params {{ $PublicStructName }}Params{{ end }}, instanceType activerecord.ShardInstanceType) (*{{ $PublicStructName }}, error) {
	logger := activerecord.Logger()
	ctx = logger.SetLoggerValueToContext(ctx, map[string]interface{}{"LuaProc": procName})
	metricTimer := activerecord.Metric().Timer("octopus", "{{ $PublicStructName }}")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "{{ $PublicStructName }}")

    metricTimer.Timing(ctx, "call_proc")

	connection, err := octopus.Box(ctx, 0, instanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "call_proc_preparebox", 1)
		logger.Error(ctx, fmt.Sprintf("Error get box '%s'", err))

		return nil, err
	}

	var args []string
	{{ if ne $procInLen 0 }}
	args, err = params.arrayValues()
	if err != nil {
		metricErrCnt.Inc(ctx, "call_proc_preparebox", 1)
		return nil, fmt.Errorf("Error parse args of procedure %s: %w", procName, err)
	}
	{{ end }}

	td, err := octopus.CallLua(ctx, connection, procName, args...)
	if err != nil {
		metricErrCnt.Inc(ctx, "call_proc", 1)
		return nil, fmt.Errorf("call lua procedure %s: %w", procName, err)
	}

    if len(td) != 1 {
        return nil, fmt.Errorf("invalid response len from lua call: %d. Only one tuple supported", len(td))
    }

	ret, err := TupleToStruct(ctx, td[0])
	if err != nil {
		metricErrCnt.Inc(ctx, "call_proc_preparebox", 1)
		logger.Error(ctx, "Error in response: ", err)

		return nil, err
	}

	metricTimer.Finish(ctx, "call_proc")

	activerecord.Logger().CollectQueries(ctx, CallMockerLogger({{ if ne $procInLen 0 }}params, {{ end }}{{ $PublicStructName }}List([]*{{ $PublicStructName }}{ret})))

	return ret, nil
}

func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*{{ $PublicStructName }}, error) {
    if tuple.Cnt < cntOutFields {
        return nil, fmt.Errorf("not enought selected fields %d in response tuple: %d but expected %d fields", tuple.Cnt, tuple.Cnt, cntOutFields)
    }

	np := {{ $PublicStructName }}{}

	{{ range $ind, $fstruct := .ProcOutFieldList -}}
	val{{ $fstruct.Name }}, err := Unpack{{ $fstruct.Name -}}(bytes.NewReader(tuple.Data[{{$ind}}]))
	if err != nil {
		return nil, err
	}

	np.field{{ $fstruct.Name }} = val{{ $fstruct.Name }}
	{{ end }}

	return &np, nil
}

{{ range $ind, $fstruct := .ProcOutFieldList -}}
	{{ $packerparam := packerParam $fstruct.Format -}}
	{{ $rtype := $fstruct.Format -}}
	{{ $sname := $fstruct.Serializer.Name -}}
	{{ if ne $sname "" -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $rtype = $serializer.Type -}}
	{{ end -}}
func (obj *{{ $PublicStructName }}) Set{{ $fstruct.Name }}({{ $fstruct.Name }} {{ $rtype }}) error {
	obj.field{{ $fstruct.Name }} = {{ $fstruct.Name}}

	return nil
}

func Unpack{{ $fstruct.Name }}(r *bytes.Reader) (ret {{ $rtype }}, errRet error) {
	var {{ $fstruct.Name }} {{ if ne $packerparam.UnpackType "" }}{{ $packerparam.UnpackType }}{{ else }}{{ $fstruct.Format }}{{ end }}
	{{ $isPointer := hasPrefix (printf "%s" $rtype) "*" }}

	err := {{ $packerparam.UnpackFunc }}(r, &{{ $fstruct.Name }}, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field {{ $fstruct.Name }} in tuple: '%w'", err)
		return
	}

	bvar := {{ if ne $packerparam.UnpackConvFunc "" -}}
		{{ $packerparam.UnpackConvFunc }}({{ $fstruct.Name }})
	{{ else -}}
		{{ $fstruct.Name }}
	{{ end -}}

	{{ $underlyingType := trimPrefix (printf "%s" $rtype) "*"}}
	{{ if ne $sname "" -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $serparams := $fstruct.Serializer.Params }}

	var svar {{$rtype}}

	err = {{ $serializer.ImportName }}.{{ $serializer.Unmarshaler }}({{ $serparams }}bvar, &svar)
	if err != nil {
		errRet = fmt.Errorf("error unmarshal field {{ $fstruct.Name }}: %w", err)
		return
	}

	{{ else -}}
	svar := bvar

	{{ end -}}

	return svar, nil
}

func pack{{ $fstruct.Name }}(w []byte, {{ $fstruct.Name }} {{ $rtype }}) ([]byte, error) {
	{{ $bvar :=  $packerparam.PackConvFunc $fstruct.Name -}}
	{{ if ne $sname "" -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $serparams := $fstruct.Serializer.Params -}}
	pvar, err := {{ $serializer.ImportName }}.{{ $serializer.Marshaler }}({{ $serparams }}{{ $bvar }})
	if err != nil {
		return nil, fmt.Errorf("error marshal field {{ $fstruct.Name }}: %w", err)
	}
	{{- else -}}
	pvar := {{ $bvar }}
	{{- end }}

	return {{ $packerparam.PackFunc }}(w, pvar, iproto.ModeDefault), nil
}
{{ end }}
// end proc struct

{{end}}

{{ if eq .Server.Conf "" -}}
var boxOption, _ = octopus.NewOptions(
	"{{ .Server.Host }}:{{ .Server.Port }}",
	octopus.ModeMaster,
	octopus.WithTimeout(time.Millisecond * {{ .Server.Timeout }}, time.Millisecond * {{ .Server.Timeout }}),
)

var clusterInfo = activerecord.NewClusterInfo(
	activerecord.WithShard([]activerecord.OptionInterface{boxOption}, []activerecord.OptionInterface{}),
){{ end }}

func New(ctx context.Context) *{{ $PublicStructName }} {
	newObj := {{ $PublicStructName }}{}
	{{- if $fields }}
	newObj.BaseField.UpdateOps = []octopus.Ops{}
	newObj.BaseField.ExtraFields = [][]byte{}
	newObj.BaseField.Objects = map[string][]octopus.ModelStruct{}
    {{ end }}
    {{- if ne $mutatorLen 0 -}}
    {{- range $i, $mut := $mutators }}
    newObj.{{$mut.Name}}.PartialFields = map[string]any{}
    {{ if ne $mut.Update "" -}}
    newObj.{{$mut.Name}}.OpFunc = map[octopus.OpCode]string{octopus.OpUpdate: "{{$mut.Update}}"}
    {{ end }}
    {{ if ne $mut.Replace "" -}}
    newObj.{{$mut.Name}}.OpFunc = map[octopus.OpCode]string{octopus.OpInsert: "{{$mut.Replace}}"}
    {{ end }}
    {{- end }}
    {{ end }}
	return &newObj
}

{{- if .Triggers.RepairTuple }}
func repairTuple(ctx context.Context, tuple *octopus.TupleData) error {
	{{- if .Triggers.RepairTuple.ImportName }}
	logger := activerecord.Logger()

	logger.Debug(ctx, "{{ $PublicStructName }}", "Repair trigger called")

	err := {{ .Triggers.RepairTuple.ImportName }}.{{ .Triggers.RepairTuple.Func }}(tuple, cntFields)
	if err != nil {
		return fmt.Errorf("trigger can't repair tuple %w", err)
	}
	{{- else if .Triggers.RepairTuple.Params.Defaults }}
	logger := activerecord.Logger()

	logger.Warn(ctx, "{{ $PublicStructName }}", "Repair trigger set defaults")
	for f := tuple.Cnt; f < cntFields; f++ {
		tuple.Data = append(tuple.Data, defaultValue[f])
	}
	tuple.Cnt = cntFields
	{{- end }}

	return nil
}
{{- end }}

{{ if $fields }}
func TupleToStruct(ctx context.Context, tuple octopus.TupleData) (*{{ $PublicStructName }}, error) {
	np := New(ctx)

	{{ range $ind, $fstruct := .FieldList -}}
	val{{ $fstruct.Name }}, err := Unpack{{ $fstruct.Name -}}(bytes.NewReader(tuple.Data[{{$ind}}]))
	if err != nil {
		return nil, err
	}

	np.Set{{ $fstruct.Name }}(val{{ $fstruct.Name }})
	{{ end }}

	np.BaseField.Exists = true
	np.BaseField.UpdateOps = []octopus.Ops{}
	{{if gt $mutatorLen 0}}
	np.ClearMutatorUpdateOpts()
	{{end}}

	if tuple.Cnt > cntFields {
		logger := activerecord.Logger()

		logger.Warn(ctx, "{{ $PublicStructName }}", np.PrimaryString(), "Extra fields")

		np.BaseField.ExtraFields = tuple.Data[cntFields:]
	}

	return np, nil
}

func NewFromBox(ctx context.Context, tuples []octopus.TupleData) ([]*{{ $PublicStructName }}, error) {
	logger := activerecord.Logger()

	logger.Debug(ctx, "{{ $PublicStructName }}", fmt.Sprintf("Cnt tuples %d", len(tuples)))

	ret := make([]*{{ $PublicStructName }}, 0, len(tuples))

	for num, tuple := range tuples {
		var repaired bool
		{{- if .Triggers.RepairTuple }}

		if tuple.Cnt != cntFields {
			err := repairTuple(ctx, &tuple)
			if err != nil {
				logger.Error(ctx, "{{ $PublicStructName }}", fmt.Errorf("%d tuple in response has %d fields but expected: %d. Repair fault: %w", num, tuple.Cnt, cntFields, err))
				continue
			}

			repaired = true
		}
		{{- end }}

		if tuple.Cnt < cntFields {
			return nil, fmt.Errorf("not enought selected fields %d in response tuple: %d but expected %d fields", tuple.Cnt, num, cntFields)
		}

		np, err := TupleToStruct(ctx, tuple)
		{{- if .Triggers.RepairTuple }}
		if err != nil {
			logger.Warn(ctx, "{{ $PublicStructName }}", fmt.Sprintf("error unpack tuple %s. Try to repair", err))

			err = repairTuple(ctx, &tuple)
			if err != nil {
				logger.Error(ctx, "{{ $PublicStructName }}", fmt.Sprintf("can't repair: %s", err))
				continue
			}

			repaired = true

			np, err = TupleToStruct(ctx, tuple)
		}
		{{- end }}
		if err != nil {
			logger.Error(ctx, "{{ $PublicStructName }}", fmt.Sprintf("error unpack tuple %s", err))
			return nil, err
		}

		np.BaseField.Repaired = repaired
		ret = append(ret, np)
	}

	return ret, nil
}
{{ end -}}

{{ range $ind, $fstruct := .FieldList -}}
	{{ $packerparam := packerParam $fstruct.Format -}}
	{{ $rtype := $fstruct.Format -}}
	{{ $sname := $fstruct.Serializer.Name -}}
	{{ if ne $sname "" -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $rtype = $serializer.Type -}}
func Marshal{{ $fstruct.Name }}({{ $fstruct.Name }} {{ $rtype }}) (any, error) {
    {{ $serparams := $fstruct.Serializer.Params -}}
    {{ $bvar :=  $packerparam.PackConvFunc $fstruct.Name -}}
    pvar, err := {{ $serializer.ImportName }}.{{ $serializer.Marshaler }}({{ $serparams }}{{ $bvar }})
    if err != nil {
        return nil, fmt.Errorf("error marshal field {{ $fstruct.Name }}: %w", err)
    }

    return pvar, nil
}

	{{ end -}}
func pack{{ $fstruct.Name }}(w []byte, {{ $fstruct.Name }} {{ $rtype }}) ([]byte, error) {
	{{ $bvar :=  $packerparam.PackConvFunc $fstruct.Name -}}
	{{ if ne $sname "" -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $serparams := $fstruct.Serializer.Params -}}
	pvar, err := {{ $serializer.ImportName }}.{{ $serializer.Marshaler }}({{ $serparams }}{{ $bvar }})
	if err != nil {
		return nil, fmt.Errorf("error marshal field {{ $fstruct.Name }}: %w", err)
	}
	{{- else -}}
	pvar := {{ $bvar }}
	{{- end }}

	return {{ $packerparam.PackFunc }}(w, pvar, iproto.ModeDefault), nil
}

func Unpack{{ $fstruct.Name }}(r *bytes.Reader) (ret {{ $rtype }}, errRet error) {
	var {{ $fstruct.Name }} {{ if ne $packerparam.UnpackType "" }}{{ $packerparam.UnpackType }}{{ else }}{{ $fstruct.Format }}{{ end }}
	{{ $isPointer := hasPrefix (printf "%s" $rtype) "*" }}

	err := {{ $packerparam.UnpackFunc }}(r, &{{ $fstruct.Name }}, iproto.ModeDefault)
	if err != nil {
		errRet = fmt.Errorf("error unpack field {{ $fstruct.Name }} in tuple: '%w'", err)
		return
	}

	bvar := {{ if ne $packerparam.UnpackConvFunc "" -}}
		{{ $packerparam.UnpackConvFunc }}({{ $fstruct.Name }})
	{{ else -}}
		{{ $fstruct.Name }}
	{{ end -}}

	{{ $underlyingType := trimPrefix (printf "%s" $rtype) "*"}}
	{{ if ne $sname "" -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $serparams := $fstruct.Serializer.Params }}

	var svar {{ $rtype }}
	
	err = {{ $serializer.ImportName }}.{{ $serializer.Unmarshaler }}({{ $serparams }}bvar, &svar)
	if err != nil {
		errRet = fmt.Errorf("error unmarshal field {{ $fstruct.Name }}: %w", err)
		return
	}

	{{ else -}}
	svar := bvar

	{{ end -}}

	return svar, nil
}

func (obj *{{ $PublicStructName }}) Get{{ $fstruct.Name }}() {{ $rtype }} {
	return obj.field{{ $fstruct.Name }}
}

func (obj *{{ $PublicStructName }}) Set{{ $fstruct.Name }}({{ $fstruct.Name }} {{ $rtype }}) error {
	{{- if $fstruct.PrimaryKey }}
	if obj.BaseField.Exists {
		return fmt.Errorf("can't modify field included in primary key")
	}

	{{ end -}}
	data, err := pack{{ $fstruct.Name }}([]byte{}, {{ $fstruct.Name }})
	if err != nil {
		return err
	}

	{{- if eq $fstruct.Format "string" "[]byte" -}}
		{{- if gt $fstruct.Size 0 }}

	if len(data) > {{ $fstruct.Size }} {
		return fmt.Errorf("max length of field '{{ $PublicStructName }}.{{ $fstruct.Name }}' is '%d' (received '%d')", {{ $fstruct.Size }}, len(data))
	}
		{{- else }}

	logger := activerecord.Logger()

	logger.Warn(context.TODO(), "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Size for field '{{ $fstruct.Name }}' not set. Cur field size: %d. Object: '{{ $PublicStructName }}'", len(data)))
		{{- end }}
	{{- end }}

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpSet, Value: data})

    {{- range $i, $mut := $fstruct.Mutators -}}
    {{ $customMutator := index $mutators $mut -}}
    {{ $pfLen := len $customMutator.PartialFields }}
    {{ if and (eq $pfLen 0) (ne $customMutator.Update "") }}
	obj.BaseField.UpdateOps = []octopus.Ops{}
    data = octopus.PackLua("{{$customMutator.Update}}", obj.PrimaryString(), {{ $fstruct.Name}})
    obj.{{ $customMutator.Name }}.UpdateOps = append(obj.{{ $customMutator.Name }}.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpUpdate, Value: data})
	{{ else if ne $pfLen 0 }}
	{{ $isPointer := hasPrefix (printf "%s" $rtype) "*" }}
	{{ if $isPointer }}
	if {{ $fstruct.Name }} != nil {
		{{- range $i, $pf := $customMutator.PartialFields }}
		if obj.Set{{ $customMutator.Name }}{{ $pf.Name }}({{ $fstruct.Name }}.{{$pf.Name}}); err != nil {
			return err
		}
		{{ end -}}
	}
	{{ else }}
		{{- range $i, $pf := $customMutator.PartialFields }}
		if obj.Set{{ $customMutator.Name }}{{ $pf.Name }}({{ $fstruct.Name }}.{{$pf.Name}}); err != nil {
			return err
		}
		{{ end }}
	{{ end }}
	obj.field{{ $customMutator.Name }}Original = obj.field{{ $fstruct.Name }}
    {{ end }}
    {{ end }}
	obj.field{{ $fstruct.Name }} = {{ $fstruct.Name}}

	{{- if ne $fstruct.ObjectLink "" }}
	delete(obj.BaseField.Objects, "{{ $fstruct.ObjectLink }}")
	{{- end }}

	return nil
}
	{{ range $i, $mut := $fstruct.Mutators -}}
    {{ $customMutator := index $mutators $mut -}}
    {{ $pfLen := len $customMutator.PartialFields }}
	{{- if $customMutator.Name }}

    {{ if ne $pfLen 0 }}
func (obj *{{ $PublicStructName }}) pack{{ $fstruct.Name }}PartialFields(op octopus.OpCode) error {
    pfs := obj.Mutators.{{ $customMutator.Name }}.PartialFields
	if len(pfs) == 0 {
		return nil
	}

    var (
            mutatorArgs []string
            err error
        )

	switch op {
    {{ if ne $customMutator.Update "" -}}
    case octopus.OpUpdate:
        mutatorArgs, err = {{ $customMutator.ImportName }}.{{ $PublicStructName }}{{ $customMutator.Name }}Update(obj.field{{ $customMutator.Name }}Original, pfs)
    {{ end }}
    {{ if ne $customMutator.Replace "" -}}
    case octopus.OpInsert:
        mutatorArgs, err = {{ $customMutator.ImportName }}.{{ $PublicStructName }}{{ $customMutator.Name }}Replace(obj.field{{ $customMutator.Name }}Original, pfs)
    {{ end }}
	}

	if err != nil {
		return err
	}

    data := octopus.PackLua(obj.Mutators.{{ $customMutator.Name }}.OpFunc[op], append([]string{obj.PrimaryString()}, mutatorArgs...)...)

	{{- if eq $fstruct.Format "string" "[]byte" -}}
		{{- if gt $fstruct.Size 0 }}

	if len(data) > {{ $fstruct.Size }} {
		return fmt.Errorf("max length of field '{{ $PublicStructName }}.{{ $fstruct.Name }}' is '%d' (received '%d')", {{ $fstruct.Size }}, len(data))
	}
		{{- else }}

	logger := activerecord.Logger()

	logger.Warn(context.TODO(), "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Size for field '{{ $fstruct.Name }}' not set. Cur field size: %d. Object: '{{ $PublicStructName }}'", len(data)))
		{{- end }}
	{{- end }}

	obj.{{ $customMutator.Name }}.UpdateOps = []octopus.Ops{}

    obj.{{ $customMutator.Name }}.UpdateOps = append(obj.{{ $customMutator.Name }}.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpUpdate, Value: data})

    return nil
}
        {{ end }}

	    {{ range $i, $f := $customMutator.PartialFields }}

func (obj *{{ $PublicStructName }}) Set{{ $customMutator.Name }}{{ $f.Name }}({{ $f.Name }} {{ $f.Type }}) error {
    obj.Mutators.{{ $customMutator.Name }}.PartialFields["{{ $f.Name }}"] = {{ $f.Name }}

	if err := obj.pack{{ $fstruct.Name }}PartialFields(octopus.OpUpdate); err != nil {
		return fmt.Errorf("pack {{ $customMutator.Name }}{{ $f.Name }}: %w", err)
	}

    return nil
}
        {{ end }}
	{{else}}
		{{ $mutatorparam := mutatorParam $mut $fstruct.Format -}}
		{{ $mtype := $fstruct.Format }}

func (obj *{{ $PublicStructName }}) {{ $mutatorparam.Name }}{{ $fstruct.Name }}(mutArg {{ $mtype }}) error {
		{{- if eq $mutatorparam.Name "Inc" }}
	if mutArg == 0 {
		return nil
	}

	if uint64({{ $packerparam.MaxValue }} - obj.field{{ $fstruct.Name }}) < uint64(mutArg) {
		return fmt.Errorf("overflow type '{{ $fstruct.Format }}' after Inc %d", mutArg)
	}

	data := iproto.PackUint32([]byte{}, uint32(mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpAdd, Value: data})
	obj.field{{ $fstruct.Name }} += {{ $packerparam.MutatorTypeConv }}(mutArg)
		{{- else if eq $mutatorparam.Name "Dec" }}
	if mutArg == 0 {
		return nil
	}

	if uint64(obj.field{{ $fstruct.Name }} - {{ $packerparam.MinValue }}) < uint64(mutArg) {
		return fmt.Errorf("overflow type '{{ $fstruct.Format }}' after Dec %d", mutArg)
	}

	data := iproto.PackUint32([]byte{}, uint32(-mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpAdd, Value: data})
	obj.field{{ $fstruct.Name }} -= {{ $packerparam.MutatorTypeConv }}(mutArg)
		{{- else if eq $mutatorparam.Name "And" }}
	if obj.field{{ $fstruct.Name }} == 0 || obj.field{{ $fstruct.Name }} & mutArg == obj.field{{ $fstruct.Name }} {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpAnd, Value: data})
	obj.field{{ $fstruct.Name }} &= mutArg
		{{- else if eq $mutatorparam.Name "Or" "SetBit" }}
	if mutArg == 0 || obj.field{{ $fstruct.Name }} | mutArg == obj.field{{ $fstruct.Name }} {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpOr, Value: data})
	obj.field{{ $fstruct.Name }} |= mutArg
		{{- else if eq $mutatorparam.Name "ClearBit" }}
	if mutArg == 0 || obj.field{{ $fstruct.Name }} & ^mutArg == obj.field{{ $fstruct.Name }} {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(^mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpAnd, Value: data})
	obj.field{{ $fstruct.Name }} &= ^mutArg
		{{- else if eq $mutatorparam.Name "Xor" }}
	if mutArg == 0 || obj.field{{ $fstruct.Name }} ^ mutArg == obj.field{{ $fstruct.Name }} {
		return nil
	}

	data := iproto.PackUint32([]byte{}, uint32(mutArg), iproto.ModeDefault)

	obj.BaseField.UpdateOps = append(obj.BaseField.UpdateOps, octopus.Ops{Field: {{ $ind }}, Op: octopus.OpXor, Value: data})
	obj.field{{ $fstruct.Name }} ^= mutArg
		{{- else }}
	Unknown mutator type in template!!!
		{{- end }}

	return nil
}
	{{- end }}
	{{- end }}
	{{- $fl := index $flags $fstruct.Name }}
	{{- if $fl }}
		{{- range $i, $flag := $fl.Flags }}

func (obj *{{ $PublicStructName }}) Set{{ $fstruct.Name }}{{ $flag }}() error {
	return obj.SetBit{{ $fstruct.Name }}( {{ $fstruct.Name }}{{ $flag }}Flag )
}

func (obj *{{ $PublicStructName }}) Clear{{ $fstruct.Name }}{{ $flag }}() error {
	return obj.ClearBit{{ $fstruct.Name }}( {{ $fstruct.Name }}{{ $flag }}Flag )
}

func (obj *{{ $PublicStructName }}) Is{{ $fstruct.Name }}{{ $flag }}() bool {
	return obj.Get{{ $fstruct.Name }}() & {{ $fstruct.Name }}{{ $flag }}Flag == {{ $fstruct.Name }}{{ $flag }}Flag
}
		{{- end }}
	{{- end }}

{{ end -}}

{{ if $fields }}
func selectBox (ctx context.Context, indexnum uint32, keysPacked [][][]byte, limiter activerecord.SelectorLimiter) ([]*{{ $PublicStructName }}, error) {
	logger := activerecord.Logger()
	ctx = logger.SetLoggerValueToContext(ctx, activerecord.ValueLogPrefix{"limiter": limiter.String()})
	metricTimer := activerecord.Metric().Timer("octopus", "{{ $PublicStructName }}")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "{{ $PublicStructName }}")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "{{ $PublicStructName }}")

	w := octopus.PackSelect(namespace, indexnum, limiter.Offset(), limiter.Limit(), keysPacked)

	metricTimer.Timing(ctx, "select_pack")
	metricStatCnt.Inc(ctx, "select_keys", float64(len(keysPacked)))

	logger.Debug(ctx, fmt.Sprintf("Select packed tuple: '% X'", w))

	connection, err := octopus.Box(ctx, 0, activerecord.ReplicaOrMasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_preparebox", 1)
		logger.Error(ctx, fmt.Sprintf("Error get box '%s'", err))

		return nil, err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeSelect, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "select_box", 1)
		logger.Error(ctx, "Error select from box", errCall, connection.Info())

		return nil, errCall
	}

	metricTimer.Timing(ctx, "select_box")

	logger.Debug(ctx, fmt.Sprintf("Response from box '%X'", respBytes))

	tuplesData, err := octopus.ProcessResp(respBytes, 0)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_resp", 1)
		logger.Error(ctx, "Error parse response: ", err)

		return nil, err
	}

	metricTimer.Timing(ctx, "select_process")
	metricStatCnt.Inc(ctx, "select_tuples_res", float64(len(tuplesData)))

	nps, err := NewFromBox(ctx, tuplesData)
	if err != nil {
		metricErrCnt.Inc(ctx, "select_preparebox", 1)
		logger.Error(ctx, "Error in response: ", err)

		return nil, err
	}

	metricTimer.Timing(ctx, "select_newobj")

	if limiter.FullfillWarn() && len(nps) == int(limiter.Limit()) {
		logger.Warn(ctx, "Select limit reached. Result may less than db records.")
	}

	mode, ok := connection.InstanceMode().(activerecord.ServerModeType)
	if !ok || mode == activerecord.ModeReplica {
		if !ok {
			logger.Error(ctx, "Invalid server mode type: %T", connection.InstanceMode())
		}

		for npNum := range nps {
			nps[npNum].IsReplica = true
			nps[npNum].Readonly = true
		}
	}

	logger.Debug(ctx, "Success select")

	metricTimer.Finish(ctx, "select")

	return nps, nil
}
{{ end }}

{{ if $fields }} // indexes
{{ $pktype := "" }}
{{ $pklenfld := 1 }}
{{ $pkind := index .Indexes 0 }}
{{ range $num, $ind := .Indexes -}}
{{ $lenfld := len $ind.Fields -}}
	{{ if $ind.Primary }}
		{{ $pktype = $ind.Type }}
		{{ $pklenfld = len $ind.Fields }}
		{{ $pkind = $ind }}
func (obj *{{ $PublicStructName }}) Primary() {{ $ind.Type }} {
		{{ if ne $lenfld 1 }}
	return {{ $ind.Type }}{
			{{- range $_, $fieldNum := $ind.Fields }}
				{{- $ifield := index $fields $fieldNum }}
		{{ $ifield.Name }}: obj.Get{{ $ifield.Name }}(),
			{{- end }}
	}
		{{ else }}
			{{- range $_, $fieldNum := $ind.Fields }}
				{{- $ifield := index $fields $fieldNum }}
	return obj.Get{{ $ifield.Name }}()
			{{- end }}
		{{ end -}}
}

func SelectByPrimary(ctx context.Context, pk {{ $ind.Type }}) (*{{ $PublicStructName }}, error) {
	return {{ $ind.Selector }}(ctx, pk)
}
	{{ end }}
{{ end }}

{{ range $num, $ind := .Indexes -}}
	{{ $lenfld := len $ind.Fields -}}
	{{ if ne $lenfld 1 }}
type {{ $ind.Type }} struct {
		{{- range $_, $fieldNum := $ind.Fields }}
			{{- $ifield := index $fields $fieldNum }}
	{{ $rtype := $ifield.Format -}}
	{{ $serlen := len $ifield.Serializer -}}
	{{ if ne $serlen 0 -}}
		{{ $sname := index $ifield.Serializer 0 -}}
		{{ $serializer := index $serializers $sname -}}
		{{ $rtype = $serializer.Type -}}
	{{ end }}
	{{ $ifield.Name }} {{ $rtype -}}
		{{- end }}
}
	{{ end -}}

func PackKeyIndex{{ $ind.Name }}(ctx context.Context, keys []{{ $ind.Type }}) ([][][]byte, error) {
	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		{{ if ne $lenfld 1 -}}
			{{ range $numf, $ifld := $ind.Fields -}}
				{{ $sfield := index $fields $ifld -}}
				{{ $packerparam := packerParam $sfield.Format -}}
				{{ $packparam := printf "key.%s" $sfield.Name -}}
				{{ $serlen := len $sfield.Serializer }}
				{{ if ne $serlen 0 }}
					{{ $sname := index $sfield.Serializer 0 -}}
					{{ $serializer := index $serializers $sname -}}
					{{ $serparams := $sfield.Serializer.Params -}}
					skey, err := {{ $serializer.ImportName }}.{{ $serializer.Marshaler }}({{ $serparams }}{{ $packparam }})
					if err != nil {
						return nil, err
					}
					{{ $packparam = "skey" }}
				{{ end }}

		keysField = append(keysField, {{ $packerparam.PackFunc }}([]byte{}, {{ $packerparam.PackConvFunc $packparam }}, iproto.ModeDefault))
			{{ end -}}
		{{ else -}}
			{{ $ifield := index $ind.Fields 0 -}}
			{{ $sfield := index $fields $ifield -}}
			{{ $packerparam := packerParam $sfield.Format -}}
		keysField = append(keysField, {{ $packerparam.PackFunc }}([]byte{}, {{ $packerparam.PackConvFunc "key" }}, iproto.ModeDefault))
		{{ end -}}
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
func UnpackKeyIndex{{ $ind.Name }}(packedKeys [][][]byte) ([]{{ $ind.Type }}, error) {
	ret := []{{ $ind.Type }}{}

	for _, packedKey := range packedKeys {
		{{ if ne $lenfld 1 }}
		newIField := {{ $ind.Type }}{}
		
		var err error

		{{- range $num, $fieldNum := $ind.Fields }}
			{{- $ifield := index $fields $fieldNum }}
			newIField.{{ $ifield.Name }}, err = Unpack{{ $ifield.Name }}(bytes.NewReader(packedKey[{{$num}}]))
			if err != nil {
				return nil, fmt.Errorf("can't unpack index: %s", err)
			}
		{{ end }}
		{{ else }}
		{{- $fieldNum := index $ind.Fields 0 }}
		{{- $ifield := index $fields $fieldNum }}
		newIField, err := Unpack{{ $ifield.Name }}(bytes.NewReader(packedKey[0]))
		if err != nil {
			return nil, fmt.Errorf("can't unpack index: %s", err)
		}
		{{ end }}
		ret = append(ret, newIField)
	}

	return ret, nil
}
/*

	keysPacked := [][][]byte{}

	for _, key := range keys {
		keysField := [][]byte{}
		{{ if ne $lenfld 1 -}}
			{{ range $numf, $ifld := $ind.Fields -}}
				{{ $sfield := index $fields $ifld -}}
				{{ $packerparam := packerParam $sfield.Format -}}
				{{ $packparam := printf "key.%s" $sfield.Name -}}
				{{ $serlen := len $sfield.Serializer }}
				{{ if ne $serlen 0 }}
					{{ $sname := index $sfield.Serializer 0 -}}
					{{ $serializer := index $serializers $sname -}}
					{{ $serparams := $sfield.Serializer.Params -}}
					skey, err := {{ $serializer.ImportName }}.{{ $serializer.Marshaler }}({{ $serparams }}{{ $packparam }})
					if err != nil {
						return nil, err
					}
					{{ $packparam = "skey" }}
				{{ end }}

		keysField = append(keysField, {{ $packerparam.PackFunc }}([]byte{}, {{ $packerparam.PackConvFunc $packparam }}, iproto.ModeDefault))
			{{ end -}}
		{{ else -}}
			{{ $ifield := index $ind.Fields 0 -}}
			{{ $sfield := index $fields $ifield -}}
			{{ $packerparam := packerParam $sfield.Format -}}
		keysField = append(keysField, {{ $packerparam.PackFunc }}([]byte{}, {{ $packerparam.PackConvFunc "key" }}, iproto.ModeDefault))
		{{ end -}}
		keysPacked = append(keysPacked, keysField)
	}

	return keysPacked, nil
}
*/
func {{ $ind.Selector }}s(ctx context.Context, keys []{{ $ind.Type }}{{ if not $ind.Unique }}, limiter activerecord.SelectorLimiter{{ end }}) ([]*{{ $PublicStructName }}, error) {
	ctx = activerecord.Logger().SetLoggerValueToContext(ctx, map[string]interface{}{"{{ $ind.Selector }}s": keys, "Repo": "{{ $PublicStructName }}" })

	keysPacked, err := PackKeyIndex{{ $ind.Name }}(ctx, keys)
	if err != nil {
		return nil, fmt.Errorf("can't pack index key: %s", err)
	}

	{{ if $ind.Unique -}}
	limiter := activerecord.EmptyLimiter()
	{{ end }}

	res, err := selectBox(ctx, {{ $ind.Num }}, keysPacked, limiter)
	if err != nil {
		return res, err	
	}

	activerecord.Logger().CollectQueries(ctx, {{ $ind.Selector }}MockerLogger(keys, {{ $PublicStructName }}List(res){{ if not $ind.Unique }}, limiter {{ end }}))

	return res, err
}

func {{ $ind.Selector }}(ctx context.Context, key {{ $ind.Type }}{{ if not $ind.Unique }}, limiter activerecord.SelectorLimiter{{ end }}) ({{ if $ind.Unique }}{{ else }}[]{{ end }}*{{ $PublicStructName }}, error) {
	selected, err := {{ $ind.Selector }}s(ctx, []{{ $ind.Type }}{key}{{ if not $ind.Unique }}, limiter{{ end }})
	if err != nil {
		return nil, err
	}

	{{ if $ind.Unique -}}
	if len(selected) > 0 {
		if len(selected) > 1 {
			activerecord.Logger().Error(ctx, "{{ $PublicStructName }}", "More than one tuple for uniq key ID '%s': %d", key, len(selected))
		}

		return selected[0], nil
	}

	return nil, nil
	{{- else }}

	return selected, nil
	{{- end }}
}
{{ end }}
{{ end }}// end indexes
{{ range $name, $fobj := .FieldObject -}}
{{ $linkedobj := index $LinkedObject $fobj.ObjectName }}
func (obj *{{ $PublicStructName }}) Get{{ $name }}(ctx context.Context) ({{ if not $fobj.Unique }}[]{{ end }}*{{ $linkedobj.Namespace.PackageName }}.{{ $linkedobj.Namespace.PublicName }}, error){
	{{- if $fobj.Unique }}
	if ret, ok := obj.BaseField.Objects["{{ $name }}"]; ok && len(ret) == 1 {
		return ret[0].(*{{ $linkedobj.Namespace.PackageName }}.{{ $linkedobj.Namespace.PublicName }}), nil
	}

	ret, err := {{ $linkedobj.Namespace.PackageName }}.SelectBy{{ $fobj.Key }}(ctx, obj.Get{{ $fobj.Field }}())
	if err != nil {
		return nil, err
	}

	obj.BaseField.Objects["{{ $name }}"] = []octopus.ModelStruct{ret}
	{{- else }}

	var ret []*{{ $linkedobj.Namespace.PackageName }}.{{ $linkedobj.Namespace.PublicName }}

	if retI, ok := obj.BaseField.Objects["{{ $name }}"]; ok && len(retI) > 0 {
		for _, ri := range retI {
			ret = append(ret, ri.(*{{ $linkedobj.Namespace.PackageName }}.{{ $linkedobj.Namespace.PublicName }}))
		}

		return ret, nil
	}

	ret, err := {{ $linkedobj.Namespace.PackageName }}.SelectBy{{ $fobj.Key }}(ctx, obj.Get{{ $fobj.Field }}(), activerecord.NewLimiter(100)) //ToDo default limit for multi object
	if err != nil {
		return nil, err
	}

	if len(ret) == 100 {
		activerecord.Logger().Warn(ctx, "limit for multiple linked object riched '{{ $linkedobj.Namespace.PackageName }}.{{ $linkedobj.Namespace.PublicName }}' '{{ $PublicStructName }}'")
	}

	for _, r := range ret {
		obj.BaseField.Objects["{{ $name }}"] = append(obj.BaseField.Objects["{{ $name }}"], r)
	}
	{{- end }}

	return ret, nil
}

{{ end -}}

{{ if $fields }}
func (obj *{{ $PublicStructName }}) Equal (anotherObjI any) bool {
	anotherObj, ok := anotherObjI.(*{{ $PublicStructName }})
	if !ok {
		return false
	}

	var dataObj []byte
	var dataAnotherObj []byte
	var err error

	{{- range $ind, $fstruct := .FieldList }} 
	dataObj, err = pack{{ $fstruct.Name }}([]byte{}, obj.Get{{ $fstruct.Name }}())
	if err != nil {
		return false
	}

	dataAnotherObj, err = pack{{ $fstruct.Name }}([]byte{}, anotherObj.Get{{ $fstruct.Name }}())
	if err != nil {
		return false
	}

	if string(dataObj) != string(dataAnotherObj) {
		return false
	}
	{{ end }}

	return true
}

func (obj *{{ $PublicStructName }}) PrimaryString() string {
	ret := []string{
	{{- range $ind, $fstruct := .FieldList }}
		{{- if $fstruct.PrimaryKey }}
			{{- $packerparam := packerParam $fstruct.Format }}
			{{- $tostr := $packerparam.ToString }} 
			{{ index $tostr 0 }}obj.Get{{ $fstruct.Name }}(){{ index $tostr 1 }},
		{{- end }}
	{{- end }}
	}

	return strings.Join(ret, ", ")
}

{{ $pktype := "" }}
{{ $pklenfld := 1 }}
{{ $pkind := index .Indexes 0 }}
{{ range $num, $ind := .Indexes -}}
{{ $lenfld := len $ind.Fields -}}
	{{ if $ind.Primary }}
		{{ $pktype = $ind.Type }}
		{{ $pklenfld = len $ind.Fields }}
		{{ $pkind = $ind }}
func (obj *{{ $PublicStructName }}) packPk() ([][]byte, error) {
	packedPk := [][]byte{}

	var (
		data []byte
		err error
	)
		{{ if ne $lenfld 1 }}
			{{- range $_, $fieldNum := $ind.Fields }}
				{{- $ifield := index $fields $fieldNum }}

					data, err = pack{{ $ifield.Name }}([]byte{}, obj.Get{{ $ifield.Name }}())
                	if err != nil {
                		return [][]byte{}, err
                	}

                	packedPk = append(packedPk, data)
			{{- end }}
		{{ else }}
			{{- range $_, $fieldNum := $ind.Fields }}
				{{- $ifield := index $fields $fieldNum }}

					data, err = pack{{ $ifield.Name }}([]byte{}, obj.Get{{ $ifield.Name }}())
                	if err != nil {
                		return [][]byte{}, err
                	}

                	packedPk = append(packedPk, data)
			{{- end }}
		{{ end }}

		return packedPk, nil
}
	{{ end }}
{{ end }}

func (obj *{{ $PublicStructName }}) Delete(ctx context.Context) error {
	logger := activerecord.Logger()
	metricTimer := activerecord.Metric().Timer("octopus", "{{ $PublicStructName }}")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "{{ $PublicStructName }}")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "{{ $PublicStructName }}")

	metricStatCnt.Inc(ctx, "delete_request", 1)

	if !obj.BaseField.Exists {
		return fmt.Errorf("can't delete not exists object")
	}

	pk, err := obj.packPk()
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_pack", 1)
		return fmt.Errorf("error delete: %w", err)
	}

	w := octopus.PackDelete(namespace, pk)
	log.Printf("Delete packed tuple: '%X'\n", w)

	connection, err := octopus.Box(ctx, 0, activerecord.MasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_preparebox", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))

		return err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeDelete, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "delete_box", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error delete from box", errCall, connection.Info())
		
		return errCall
	}

	metricTimer.Timing(ctx, "delete_box")

	logger.Debug(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Response from box '% X'", respBytes))

	_, err = octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "delete_resp", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error parse response: ", err)
		
		return err
	}

	metricStatCnt.Inc(ctx, "delete_success", 1)

	obj.BaseField.Exists = false
	obj.BaseField.UpdateOps = []octopus.Ops{}

	logger.Debug(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Success delete")

	metricTimer.Finish(ctx, "delete")

	return nil
}

func (obj *{{ $PublicStructName }}) Update(ctx context.Context) error {
	logger := activerecord.Logger()
	metricTimer := activerecord.Metric().Timer("octopus", "{{ $PublicStructName }}")
	metricStatCnt := activerecord.Metric().StatCount("octopus", "{{ $PublicStructName }}")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "{{ $PublicStructName }}")

	metricStatCnt.Inc(ctx, "update_request", 1)

	if !obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "update_notexists", 1)
		return fmt.Errorf("can't update not exists object")
	}

	if obj.BaseField.Repaired {
		metricStatCnt.Inc(ctx, "update_repaired", 1)
		logger.Debug(ctx, "", obj.PrimaryString(), "Flag 'Repaired' is true! Insert instead Update")

		return obj.Replace(ctx)
	}

	connection, err := octopus.Box(ctx, 0, activerecord.MasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "update_preparebox", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))
		return err
	}

{{if eq $mutatorLen 0}}
	if len(obj.BaseField.UpdateOps) == 0 {
		metricStatCnt.Inc(ctx, "update_empty", 1)
		logger.Debug(ctx, "", obj.PrimaryString(), "Empty update")

		return nil
	}
{{else}}
	if len(obj.BaseField.UpdateOps) > 0 {
{{- end }}
	pk, err := obj.packPk()
	if err != nil {
		metricErrCnt.Inc(ctx, "update_packpk", 1)
		return fmt.Errorf("error update: %w", err)
	}

	w := octopus.PackUpdate(namespace, pk, obj.BaseField.UpdateOps)

	log.Printf("Update packed tuple: '%X'\n", w)

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeUpdate, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "update_box", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error update ia a box", errCall, connection.Info())
		return errCall
	}

	metricTimer.Timing(ctx, "update_box")

	logger.Debug(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Response from box '%X'", respBytes))

	_, err = octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "update_resp", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error parse response: ", err)
		return err
	}

{{if gt $mutatorLen 0}}
	}
{{end}}
{{if gt $mutatorLen 0}}
{{ range $ind, $fstruct := .FieldList -}}
	{{- range $i, $mut := $fstruct.Mutators -}}
		{{ $customMutator := index $mutators $mut -}}
		{{ $pfLen := len $customMutator.PartialFields }}
		{{ if and (ne $pfLen 0) (ne $customMutator.Update "") $customMutator.Name }}
	for _, op := range obj.{{$customMutator.Name}}.UpdateOps {
		resp, errCall := connection.Call(ctx, octopus.RequestTypeCall, op.Value)
		if errCall != nil {
			metricErrCnt.Inc(ctx, "call_proc", 1)
			logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error call proc in a box", errCall, connection.Info())
			return errCall
		}

		_, err := octopus.ProcessResp(resp, 0)
		if err != nil {
			return fmt.Errorf("error unpack lua response: %w", err)
		}
	}

	obj.{{$customMutator.Name}}.UpdateOps = []octopus.Ops{}
	obj.{{$customMutator.Name}}.PartialFields = map[string]any{}
		{{end}}
	{{end}}
{{end}}
{{end}}

	obj.BaseField.UpdateOps = []octopus.Ops{}

	logger.Debug(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Success update")

	metricStatCnt.Inc(ctx, "update_success", 1)
	metricTimer.Finish(ctx, "update")

	return nil
}

func (obj *{{ $PublicStructName }}) Insert(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "{{ $PublicStructName }}")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "{{ $PublicStructName }}")

	metricStatCnt.Inc(ctx, "insert_request", 1)

	if obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "insert_exists", 1)
		return fmt.Errorf("can't insert already exists object")
	}

	err := obj.insertReplace(ctx, octopus.InsertModeInsert)

	if err == nil {
		metricStatCnt.Inc(ctx, "insert_success", 1)
	}

	return err
}

func (obj *{{ $PublicStructName }}) Replace(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "{{ $PublicStructName }}")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "{{ $PublicStructName }}")

	metricStatCnt.Inc(ctx, "replace_request", 1)

	if !obj.BaseField.Exists {
		metricErrCnt.Inc(ctx, "replace_notexists", 1)
		return fmt.Errorf("can't replace not exists object")
	}

	err := obj.insertReplace(ctx, octopus.InsertModeReplace)

	if err == nil {
		metricStatCnt.Inc(ctx, "replace_success", 1)
	}

	return err
}

func (obj *{{ $PublicStructName }}) InsertOrReplace(ctx context.Context) error {
	metricStatCnt := activerecord.Metric().StatCount("octopus", "{{ $PublicStructName }}")

	metricStatCnt.Inc(ctx, "insertorreplace_request", 1)

	err := obj.insertReplace(ctx, octopus.InsertModeInserOrReplace)

	if err == nil {
		metricStatCnt.Inc(ctx, "insertorreplace_success", 1)
	}

	return err
}

func (obj *{{ $PublicStructName }}) insertReplace(ctx context.Context, insertMode octopus.InsertMode) error {
	var (
		err error
		tuple [][]byte
		data []byte
	)

	metricTimer := activerecord.Metric().Timer("octopus", "{{ $PublicStructName }}")
	metricErrCnt := activerecord.Metric().ErrorCount("octopus", "{{ $PublicStructName }}")

	{{ range $ind, $fstruct := .FieldList }}

	data, err = pack{{ $fstruct.Name }}([]byte{}, obj.Get{{ $fstruct.Name }}())
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_packfield", 1)
		return err
	}

	tuple = append(tuple, data)
	{{ end }}

	metricTimer.Timing(ctx, "insertreplace_packtuple")

	if len(obj.BaseField.ExtraFields) > 0 {
		tuple = append(tuple, obj.BaseField.ExtraFields...)
	}

	w := octopus.PackInsertReplace(namespace, insertMode, tuple)
	logger := activerecord.Logger()

	metricTimer.Timing(ctx, "insertreplace_pack")
	logger.Trace(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Insert packed tuple: '%X'", w))

	connection, err := octopus.Box(ctx, 0, activerecord.MasterInstanceType, "arcfg", nil)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_preparebox", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Error get box '%s'", err))

		return err
	}

	respBytes, errCall := connection.Call(ctx, octopus.RequestTypeInsert, w)
	if errCall != nil {
		metricErrCnt.Inc(ctx, "insertreplace_box", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error insert into box", errCall, connection.Info())

		return errCall
	}

	metricTimer.Timing(ctx, "insertreplace_box")

	logger.Trace(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), fmt.Sprintf("Response from box '%X'", respBytes))

	tuplesData, err := octopus.ProcessResp(respBytes, octopus.NeedRespFlag|octopus.UniqRespFlag)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_prespreparebox", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error parse response: ", err)

		return err
	}

	_, err = NewFromBox(ctx, tuplesData)
	if err != nil {
		metricErrCnt.Inc(ctx, "insertreplace_obj", 1)
		logger.Error(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Error in response: ", err)

		return err
	}

	obj.BaseField.Exists = true
	obj.BaseField.UpdateOps = []octopus.Ops{}
	{{- if gt $mutatorLen 0 }}
	obj.ClearMutatorUpdateOpts()
	{{- end }}
	obj.BaseField.Repaired = false

	logger.Debug(ctx, "{{ $PublicStructName }}", obj.PrimaryString(), "Success insert")

	metricTimer.Finish(ctx, "insertreplace")

	return nil
}
{{ end }}
{{if gt $mutatorLen 0}}
func (obj *{{ $PublicStructName }}) ClearMutatorUpdateOpts() {
{{- range $ind, $fstruct := .FieldList -}}
	{{- range $i, $mut := $fstruct.Mutators -}}
		{{ $customMutator := index $mutators $mut -}}
		{{ if and (ne $customMutator.Update "") $customMutator.Name -}}
	obj.{{$customMutator.Name}}.UpdateOps = []octopus.Ops{}
	obj.{{$customMutator.Name}}.PartialFields = map[string]any{}
		{{- end }}
	{{end}}
{{- end -}}
}
{{end}}